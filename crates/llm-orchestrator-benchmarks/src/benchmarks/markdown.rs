// Copyright (c) 2025 LLM DevOps
// SPDX-License-Identifier: Apache-2.0

//! Markdown report generation for benchmark results.

use super::result::BenchmarkResult;
use chrono::Utc;

/// Generates a comprehensive markdown report from benchmark results.
///
/// The report includes:
/// - Header with generation timestamp
/// - Summary statistics
/// - Individual target results with metrics tables
/// - Performance comparison if multiple runs are available
///
/// # Arguments
///
/// * `results` - Slice of BenchmarkResult to include in the report
///
/// # Returns
///
/// A String containing the formatted markdown report.
///
/// # Example
///
/// ```rust
/// use llm_orchestrator_benchmarks::benchmarks::markdown::generate_markdown_report;
/// use llm_orchestrator_benchmarks::benchmarks::result::BenchmarkResult;
/// use serde_json::json;
///
/// let results = vec![
///     BenchmarkResult::new("workflow_execution", json!({
///         "duration_ms": 150.5,
///         "iterations": 100
///     })),
/// ];
///
/// let markdown = generate_markdown_report(&results);
/// assert!(markdown.contains("workflow_execution"));
/// ```
pub fn generate_markdown_report(results: &[BenchmarkResult]) -> String {
    let mut report = String::new();

    // Header
    report.push_str("# LLM Orchestrator Benchmark Results\n\n");
    report.push_str(&format!(
        "Generated: {}\n\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    // Summary section
    report.push_str("## Summary\n\n");
    report.push_str(&format!("- **Total Benchmarks**: {}\n", results.len()));

    if !results.is_empty() {
        let durations: Vec<f64> = results.iter().filter_map(|r| r.duration_ms()).collect();

        if !durations.is_empty() {
            let total_duration: f64 = durations.iter().sum();
            let avg_duration = total_duration / durations.len() as f64;
            let min_duration = durations.iter().cloned().fold(f64::INFINITY, f64::min);
            let max_duration = durations.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

            report.push_str(&format!(
                "- **Total Duration**: {:.2} ms\n",
                total_duration
            ));
            report.push_str(&format!(
                "- **Average Duration**: {:.2} ms\n",
                avg_duration
            ));
            report.push_str(&format!("- **Min Duration**: {:.2} ms\n", min_duration));
            report.push_str(&format!("- **Max Duration**: {:.2} ms\n", max_duration));
        }
    }

    report.push('\n');

    // Results table
    report.push_str("## Benchmark Results\n\n");
    report.push_str("| Target | Duration (ms) | Iterations | Ops/sec | Status |\n");
    report.push_str("|--------|---------------|------------|---------|--------|\n");

    for result in results {
        let duration = result
            .duration_ms()
            .map(|d| format!("{:.2}", d))
            .unwrap_or_else(|| "-".to_string());
        let iterations = result
            .iterations()
            .map(|i| i.to_string())
            .unwrap_or_else(|| "-".to_string());
        let ops_per_sec = result
            .ops_per_sec()
            .map(|o| format!("{:.2}", o))
            .unwrap_or_else(|| "-".to_string());

        let status = if result.metrics.get("error").is_some() {
            "❌ Failed"
        } else {
            "✅ Passed"
        };

        report.push_str(&format!(
            "| {} | {} | {} | {} | {} |\n",
            result.target_id, duration, iterations, ops_per_sec, status
        ));
    }

    report.push('\n');

    // Detailed results section
    report.push_str("## Detailed Results\n\n");

    for result in results {
        report.push_str(&format!("### {}\n\n", result.target_id));
        report.push_str(&format!(
            "**Timestamp**: {}\n\n",
            result.timestamp.format("%Y-%m-%d %H:%M:%S UTC")
        ));

        report.push_str("**Metrics**:\n\n");
        report.push_str("```json\n");
        report.push_str(
            &serde_json::to_string_pretty(&result.metrics).unwrap_or_else(|_| "{}".to_string()),
        );
        report.push_str("\n```\n\n");
    }

    // Footer
    report.push_str("---\n\n");
    report.push_str("*Generated by llm-orchestrator-benchmarks*\n");

    report
}

/// Generates a compact one-line summary for each benchmark result.
///
/// Useful for CI/CD output or quick status checks.
pub fn generate_compact_summary(results: &[BenchmarkResult]) -> String {
    let mut summary = String::new();

    for result in results {
        let duration = result
            .duration_ms()
            .map(|d| format!("{:.2}ms", d))
            .unwrap_or_else(|| "N/A".to_string());

        let status = if result.metrics.get("error").is_some() {
            "FAIL"
        } else {
            "PASS"
        };

        summary.push_str(&format!(
            "[{}] {} - {} ({})\n",
            status, result.target_id, duration, result.timestamp.format("%H:%M:%S")
        ));
    }

    summary
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_generate_markdown_report() {
        let results = vec![
            BenchmarkResult::new(
                "test_target_1",
                json!({
                    "duration_ms": 100.5,
                    "iterations": 1000,
                    "ops_per_sec": 9950.25
                }),
            ),
            BenchmarkResult::new(
                "test_target_2",
                json!({
                    "duration_ms": 50.0,
                    "iterations": 500
                }),
            ),
        ];

        let report = generate_markdown_report(&results);

        assert!(report.contains("# LLM Orchestrator Benchmark Results"));
        assert!(report.contains("test_target_1"));
        assert!(report.contains("test_target_2"));
        assert!(report.contains("100.5"));
        assert!(report.contains("| Target |"));
    }

    #[test]
    fn test_generate_compact_summary() {
        let results = vec![BenchmarkResult::new(
            "quick_test",
            json!({
                "duration_ms": 25.0
            }),
        )];

        let summary = generate_compact_summary(&results);

        assert!(summary.contains("[PASS]"));
        assert!(summary.contains("quick_test"));
        assert!(summary.contains("25.00ms"));
    }

    #[test]
    fn test_error_status_in_report() {
        let results = vec![BenchmarkResult::new(
            "failed_test",
            json!({
                "duration_ms": 0.0,
                "error": "Something went wrong"
            }),
        )];

        let report = generate_markdown_report(&results);
        assert!(report.contains("❌ Failed"));

        let summary = generate_compact_summary(&results);
        assert!(summary.contains("[FAIL]"));
    }
}
